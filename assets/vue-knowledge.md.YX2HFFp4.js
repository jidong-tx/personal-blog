import{_ as i,c as s,o as e,ae as a}from"./chunks/framework.aUVN3Dp1.js";const g=JSON.parse('{"title":"","description":"","frontmatter":{"outline":"deep"},"headers":[],"relativePath":"vue-knowledge.md","filePath":"vue-knowledge.md"}'),l={name:"vue-knowledge.md"};function n(h,t,p,k,d,r){return e(),s("div",null,t[0]||(t[0]=[a(`<h2 id="vue-生命周期" tabindex="-1">Vue 生命周期 <a class="header-anchor" href="#vue-生命周期" aria-label="Permalink to &quot;Vue 生命周期&quot;">​</a></h2><table tabindex="0"><thead><tr><th style="text-align:left;">Vue2 选项式</th><th style="text-align:center;">Vue3 选项式</th><th style="text-align:center;">Vue3 组合式</th><th style="text-align:left;">作用</th></tr></thead><tbody><tr><td style="text-align:left;">beforeCreate</td><td style="text-align:center;">beforeCreate</td><td style="text-align:center;">setup()</td><td style="text-align:left;">在实例初始化之后,数据观测和事件配置之前被调用</td></tr><tr><td style="text-align:left;">created</td><td style="text-align:center;">created</td><td style="text-align:center;">onBeforeMount</td><td style="text-align:left;">在实例创建完成后被立即调用,此时已完成数据观测、属性和方法的运算、watch/event 事件回调</td></tr><tr><td style="text-align:left;">beforeMount</td><td style="text-align:center;">onBeforeMount</td><td style="text-align:center;">onBeforeMount</td><td style="text-align:left;">在挂载开始之前被调用,相关 render 函数首次被调用</td></tr><tr><td style="text-align:left;">mounted</td><td style="text-align:center;">mounted</td><td style="text-align:center;">onMounted</td><td style="text-align:left;">onMounted 组件挂载到 DOM 后调用,可获取 DOM 节点</td></tr><tr><td style="text-align:left;">beforeUpdate</td><td style="text-align:center;">beforeUpdate</td><td style="text-align:center;">onBeforeUpdate</td><td style="text-align:left;">数据更新时调用,发生在虚拟 DOM 打补丁之前</td></tr><tr><td style="text-align:left;">updated</td><td style="text-align:center;">updated</td><td style="text-align:center;">onUpdated</td><td style="text-align:left;">数据更改导致的虚拟 DOM 重新渲染和打补丁,之后会调用此钩子</td></tr><tr><td style="text-align:left;">beforeDestroy</td><td style="text-align:center;">beforeUnmount</td><td style="text-align:center;">onBeforeUnmount</td><td style="text-align:left;">在卸载组件实例之前调用,实例仍然完全可用</td></tr><tr><td style="text-align:left;">destroyed</td><td style="text-align:center;">unmounted</td><td style="text-align:center;">onUnmounted</td><td style="text-align:left;">在卸载组件实例之后调用,清理操作在该钩子中进行</td></tr><tr><td style="text-align:left;">errorCaptured</td><td style="text-align:center;">errorCaptured</td><td style="text-align:center;">onErrorCaptured</td><td style="text-align:left;">当捕获一个来自子孙组件的错误时被调用</td></tr></tbody></table><h3 id="为什么-beforecreate-对标的是-setup" tabindex="-1">为什么 beforeCreate 对标的是 setup <a class="header-anchor" href="#为什么-beforecreate-对标的是-setup" aria-label="Permalink to &quot;为什么 beforeCreate 对标的是 setup&quot;">​</a></h3><ul><li>beforeCreate 在实例被创建之后,data 和 methods 还未初始化之前调用</li><li>setup 在组件创建之后, data 和 methods 初始化之前被调用</li></ul><h3 id="为什么-created-对标的是-onbeforemount" tabindex="-1">为什么 created 对标的是 onBeforeMount <a class="header-anchor" href="#为什么-created-对标的是-onbeforemount" aria-label="Permalink to &quot;为什么 created 对标的是 onBeforeMount&quot;">​</a></h3><ul><li>created 在组件实例被创建之后调用,这个时候还没有开始 DOM 的挂载,data 数据对象就已经被初始化好了。</li><li>onBeforeMount 会在组件挂载到 DOM 之前调用,这个时候数据已经初始化完成,但是还没有开始 DOM 渲染。 <ul><li>所以其功能与 created 类似,都是表示实例初始化完成,但还未开始 DOM 渲染。</li></ul></li></ul><h2 id="组件间的通信方式" tabindex="-1">组件间的通信方式 <a class="header-anchor" href="#组件间的通信方式" aria-label="Permalink to &quot;组件间的通信方式&quot;">​</a></h2><table tabindex="0"><thead><tr><th style="text-align:left;">通信方式</th><th style="text-align:center;">说明</th><th style="text-align:center;">优点</th><th style="text-align:left;">缺点</th></tr></thead><tbody><tr><td style="text-align:left;">事件总线</td><td style="text-align:center;">利用空 Vue 实例作为消息总线</td><td style="text-align:center;">简单，低耦合</td><td style="text-align:left;">难维护，调试难度大</td></tr><tr><td style="text-align:left;">本地存储</td><td style="text-align:center;">localStorage、sessionStorage</td><td style="text-align:center;">简单，低耦合</td><td style="text-align:left;">没有响应式，需要手动同步</td></tr><tr><td style="text-align:left;">状态管理工具</td><td style="text-align:center;">vuex、pinia 等状态管理工具</td><td style="text-align:center;">简单，低耦合</td><td style="text-align:left;">需要学习成本，维护难度大</td></tr><tr><td style="text-align:left;">父子组件通信</td><td style="text-align:center;">父子组件通信 props $emit</td><td style="text-align:center;">简单，低耦合</td><td style="text-align:left;">只能单向，父子组件间才有效</td></tr><tr><td style="text-align:left;">provide/inject</td><td style="text-align:center;">依赖注入，可跨多层级</td><td style="text-align:center;">低耦合，方便访问父级数据</td><td style="text-align:left;">只适用于父子孙组件间，vue3 可以响应式</td></tr></tbody></table><h2 id="动态组件" tabindex="-1">动态组件 <a class="header-anchor" href="#动态组件" aria-label="Permalink to &quot;动态组件&quot;">​</a></h2><p>有些场景会需要在两个组件间来回切换，比如 Tab 界面：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Home </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;./Home.vue&#39;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Posts </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;./Posts.vue&#39;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Archive </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;./Archive.vue&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> currentTab</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ref</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Home&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> tabs</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        Home,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        Posts,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        Archive</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    &lt;!--</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> currentTab 改变时组件也改变 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">--&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">component</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;"> :is=&quot;tabs[currentTab]&quot;&gt;&lt;/component&gt;</span></span></code></pre></div><p>在上面的例子中，被传给 :is 的值可以是以下几种：</p><ul><li>被注册的组件名</li><li>导入的组件对象</li></ul><h2 id="keep-alive" tabindex="-1">keep-alive <a class="header-anchor" href="#keep-alive" aria-label="Permalink to &quot;keep-alive&quot;">​</a></h2><p>keep-alive 是 Vue 提供的一个内置组件，可以使被包含的组件保留状态，避免反复重渲染，使用 keep-alive 进行缓存的组件会多两个生命周期钩子函数：activated、deactivated</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;!--</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 使用keep</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">alive包裹动态组件 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">--&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">keep-alive</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">component</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;"> :is=&quot;currentComponent&quot;&gt;&lt;/component&gt;</span></span>
<span class="line"><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">  &lt;/keep-alive&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">  &lt;!--</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> 动态切换组件</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;"> --&gt;</span></span>
<span class="line"><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">  &lt;button</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;"> @click=&quot;currentComponent</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;A&#39;&quot;&gt;Show A&lt;/button&gt;</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &lt;button @click=&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">currentComponent</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;B&#39;&quot;&gt;Show B&lt;/button&gt;</span></span></code></pre></div><h4 id="实现机制" tabindex="-1">实现机制 <a class="header-anchor" href="#实现机制" aria-label="Permalink to &quot;实现机制&quot;">​</a></h4><ol><li><p>keep-alive 组件会在内部维护一个对象 cache，用来存储缓存的组件实例。</p></li><li><p>在组件切换时，优先获取 include 内的组件，过滤 exclude 内的组件，然后再检查缓存中是否已经有实例</p><ul><li>如果有，就直接从缓存中取出实例进行渲染</li><li>如果没有，就创建一个新的实例进行渲染，并存储到缓存中</li></ul></li><li><p>当组件不再需要时，可以通过 max 属性来控制缓存的实例数量。如果超出这个数量，就会按照 LRU（最近最少使用）算法进行淘汰。</p></li><li><p>keep-alive 组件还提供了两个生命周期钩子：activated 和 deactivated。这两个钩子会在组件被激活和停用时触发，可以用来执行一些清理或初始化操作。</p></li></ol><h2 id="异步更新队列" tabindex="-1">异步更新队列 <a class="header-anchor" href="#异步更新队列" aria-label="Permalink to &quot;异步更新队列&quot;">​</a></h2><p>这里引用官方的一句话：<strong><em>可能你还没有注意到，Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更</em></strong></p><h4 id="为什么需要异步更新-dom-呢" tabindex="-1">为什么需要异步更新 DOM 呢？ <a class="header-anchor" href="#为什么需要异步更新-dom-呢" aria-label="Permalink to &quot;为什么需要异步更新 DOM 呢？&quot;">​</a></h4><p>假设一个场景<br> html</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;{{ title }}&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>js</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">test</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 100</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.title </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> \`第\${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">i</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}个标题\`</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mounted</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  test</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ul><li>这里我们在 test 中使用修改了 title，假设一下，如果没有异步更新这个 dom，那么就要操作 100 次，为了避免这种无意义的性能消耗，Vue 再侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。</li><li>如果在同一事件循环中多次更新 DOM,会导致不必要的计算和 DOM 操作。将它们 defer 到下一个事件循环执行,可以有效减少开销。</li><li>如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作</li></ul><h4 id="nexttick-实现原理" tabindex="-1">nextTick 实现原理 <a class="header-anchor" href="#nexttick-实现原理" aria-label="Permalink to &quot;nextTick 实现原理&quot;">​</a></h4><ul><li><p>nextTick 作用：<br> 在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。</p></li><li><p><strong><em>实现原理:</em></strong></p></li></ul><ol><li>nextTick 接收一个回调函数作为参数</li><li>内部会维护一个异步回调队列数组</li><li>将传入的回调推入这个异步队列</li><li>在微任务(promise.then/MutationObserver)空闲时刻执行队列中的回调</li><li>达成在 DOM 更新后执行回调的效果</li></ol><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> callbacks </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> []; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 异步回调队列</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> nextTick</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">cb</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  callbacks.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">push</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(cb); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 推入回调队列</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 微任务执行callbacks</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(flushCallbacks);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> flushCallbacks</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  callbacks.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">forEach</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">cb</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> cb</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 执行队列回调</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  callbacks </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> []; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 重置队列</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="常见的性能优化方式-结合项目场景" tabindex="-1">常见的性能优化方式（结合项目场景） <a class="header-anchor" href="#常见的性能优化方式-结合项目场景" aria-label="Permalink to &quot;常见的性能优化方式（结合项目场景）&quot;">​</a></h2><p>在实际项目中，Vue 的性能优化需要根据具体的场景和需求来选择合适的策略。以下是一些常见的 Vue 性能优化方式，结合项目场景进行总结：</p><ol><li>使用生产环境构建： <ul><li>在生产环境中使用 Vue 的生产版本，以减少体积和提高性能。</li></ul></li><li>异步组件和路由懒加载： <ul><li>对于大型项目，使用异步组件和路由懒加载，以分割代码并实现按需加载，减小初始加载体积。</li></ul></li><li>合理使用 v-if 和 v-show： <ul><li>对于频繁切换的元素，使用 v-show，对于不经常切换的元素，使用 v-if，以减少 DOM 元素的挂载和卸载。</li></ul></li><li>合理使用 v-for： <ul><li>遍历大数据集时，避免在模板中访问复杂度较高的属性，最好在数据源中进行预处理。如果数据不变，可以考虑使用 Object.freeze 冻结对象，以防止 Vue 的响应式系统监听它。</li></ul></li><li>合理使用计算属性和 Watch： <ul><li>将复杂的计算逻辑放入计算属性，避免在模板中进行复杂的计算。使用 deep 选项和 immediate 选项来优化 Watcher。</li></ul></li><li>合理使用事件委托： <ul><li>在父组件上使用事件委托，将事件处理推移到父组件上，以减少子组件的监听器数量。</li></ul></li><li>合理使用 keep-alive： <ul><li>对于频繁切换的组件，可以考虑使用 <code>&lt;keep-alive&gt;</code> 缓存组件实例，以减少组件的销毁和重新创建。</li></ul></li><li>合理使用缓存 <ul><li>利用缓存机制，例如在数据请求结果中使用缓存，以避免不必要的重复请求。</li></ul></li><li>合理使用过渡效果和动画： <ul><li>控制过渡效果和动画的触发时机，避免在大量元素上使用过渡效果，以提高性能。</li></ul></li><li>优化网络请求 - 使用合适的数据加载方式，例如分页加载或滚动加载，以降低页面初始化时的请求量。</li><li>性能监控和分析 - 使用工具进行性能监控和分析，例如 Chrome DevTools、Vue DevTools 等，及时发现和解决性能问题</li></ol><h2 id="vue3-ref-和-reactive-区别-如何选择" tabindex="-1">Vue3 ref 和 reactive 区别，如何选择? <a class="header-anchor" href="#vue3-ref-和-reactive-区别-如何选择" aria-label="Permalink to &quot;Vue3 ref 和 reactive 区别，如何选择?&quot;">​</a></h2><table tabindex="0"><thead><tr><th style="text-align:left;">ref()</th><th style="text-align:left;">reactive()</th></tr></thead><tbody><tr><td style="text-align:left;">✔ 支持基本数据类型+引用数据类型</td><td style="text-align:left;">❌ 只支持引用数据类型（对象或数组）</td></tr><tr><td style="text-align:left;">❌ 在 <code>&lt;script&gt;</code> 和 <code>&lt;template&gt;</code> 使用方式不同(script 中要.value)</td><td style="text-align:left;">✔ 在 <code>&lt;script&gt;</code> 和 <code>&lt;template&gt;</code> 使用方式相同</td></tr><tr><td style="text-align:left;">✔ 重新分配一个新对象不会失去响应式</td><td style="text-align:left;">❌ 重新分配一个新对象会失去响应性</td></tr><tr><td style="text-align:left;">需要使用 .value 访问属性</td><td style="text-align:left;">直接访问属性即可</td></tr><tr><td style="text-align:left;">✔ 传入函数时,不会失去响应性</td><td style="text-align:left;">❌ 传入函数时,会失去响应性</td></tr><tr><td style="text-align:left;">✔ 解构对象时会丢失响应性,需使用 toRefs()</td><td style="text-align:left;">❌ 解构时会丢失响应性,需使用 toRefs</td></tr></tbody></table>`,35)]))}const c=i(l,[["render",n]]);export{g as __pageData,c as default};
